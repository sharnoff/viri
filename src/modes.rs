//! Various cursor modes, mode-switching, and handling of the mode stack
//!
//! To explain the purpose of this module, it's first worth describing what a "mode" actually is.
//! For the purposes of this module, a mode is an abstract interface, taking in a set of key
//! events and emitting commands to execute. These are collected into a "mode set", which
//! additionally handles switching between modes within the set.
//!
//! [`Mode`]s are generic over the output type; the output type is only required to have some way to
//! extract information about switching modes and limit

use crate::any::Any;
use crate::keys::{KeyEvent, KeybindingSet};
use crate::macros::id;
use smallvec::SmallVec;
use std::collections::HashMap;
use std::mem;
use std::sync::Arc;

/// An individual keybinding mode
///
/// These are typically only accessed as part of a [`ModeSet`]. For more information on how `Mode`s
/// work, refer to the [module-level documentation](self).
pub struct Mode<T: ModeOutput> {
    // The user-defined name of the mode
    name: String,
    kind: ModeKind,
    // Any unprocessed input
    input: Vec<KeyEvent>,
    keys: Arc<KeybindingSet<T>>,
}

/// A distinct set of [`Mode`]s; the primary executor for mode inputs
///
/// Constructing a `ModeSet` is done from a hashmap of each mode's name and a way to construct its
/// keybindings, using the [`ModeSet::new`] method.
pub struct ModeSet<T: ModeOutput> {
    // Each individual mode in the set, represented by its name and the keybindings it's constructed
    // from
    set: Vec<(String, Arc<KeybindingSet<T>>)>,

    // The indices in `set` corresponding to each named mode
    index: HashMap<String, ModeKind>,

    // The current mode, alongside its name
    current: Mode<T>,
}

id! {
    /// A unqiue identifier for types of `Mode`s within a [`ModeSet`]
    ///
    /// Typical usage of these only exists as an argument to the [`KeybindingSet`] constructors
    /// given in [`ModeSet::new`], but `ModeKind`s can also be generated by the [`ModeSet::kind`]
    /// method.
    ///
    /// The interface here is intentionally restricted so that changing modes can be made infallible
    /// after program startup.
    pub struct ModeKind in <T: ModeOutput> [(String, Arc<KeybindingSet<T>>)];
}

/// A marker trait for types that may be used as a command output for [`Mode`]s
pub trait ModeOutput: 'static + Any + Send + Sync {
    /// If the output allows switching to a new mode, returns the mode that it switched to
    ///
    /// Switching modes will be respected, even if there
    // @def switch-modes-respected v0
    fn as_switch_mode(&self) -> Option<ModeKind>;

    /// Indicates that this output will cause a switch to a different [`ModeSet`] (typically a
    /// different signifying a different [`View`])
    ///
    /// This is used to end the batch of input processing early if that's the case.
    fn switches_provider(&self) -> bool;

    /// An error constructor, used to indicate that there was no matching keybinding for the
    /// provided input
    fn make_failed(keys: Vec<KeyEvent>) -> Self;
}

/// (*Internal*) Indicates the result of an attempted keybinding match
enum MatchResult<T> {
    Ok(T),
    NeedsMore,
    Failed(Vec<KeyEvent>),
}

impl<T: ModeOutput> ModeSet<T> {
    /// Constructs a new `ModeSet`, given the name of each mode and a way to construct the
    /// corresponding `KeybindingSet`
    ///
    /// Each constructor is supplied a unique [`ModeKind`] associated with the particular [`Mode`]
    /// being made, so that - wherever possible - mappings may be made in order to ensure that
    /// attempting to switch to a mode with a name that does not exist cannot happen during normal
    /// program runtime.
    ///
    /// The name of the starting mode given must be within the set, or else this function will
    /// panic.
    pub fn new(
        modes: HashMap<String, impl FnOnce(ModeKind) -> KeybindingSet<T>>,
        starting_mode: &str,
    ) -> Self {
        if !modes.contains_key(starting_mode) {
            panic!(
                "cannot construct `ModeSet`; starting mode {:?} not within supplied set",
                starting_mode
            );
        }

        let mut set = Vec::new();
        let mut index = HashMap::new();
        for (name, cons) in modes {
            let kind = ModeKind(set.len());
            index.insert(name.clone(), kind);
            set.push((name, Arc::new(cons(kind))));
        }

        let starting_kind = *index.get(starting_mode).unwrap();
        let keys = Arc::clone(&set[starting_kind].1);

        ModeSet {
            set,
            index,
            current: Mode::new(starting_mode.to_owned(), starting_kind, keys),
        }
    }

    /// Returns a unique identifier for the `Mode` with the given name in this set
    ///
    /// If there is no mode with that name in the set, this method returns `None`. It is the
    /// responsibility of the caller to handle resulting errors.
    pub fn kind(&self, name: &str) -> Option<ModeKind> {
        self.index.get(name).cloned()
    }

    /// Returns a reference to the name of the current mode
    pub fn current_mode_name(&self) -> &str {
        &self.current.name
    }

    /// Returns a reference to the keys that are currently waiting to be consumed
    ///
    /// If this list is non-empty, it indicates that the `ModeSet` is waiting for more input in
    /// order to determine what to do.
    pub fn current_buffer(&self) -> &[KeyEvent] {
        &self.current.input
    }

    /// Processes a batch of inputs, returning the relevant outputs, if any
    ///
    /// This function typically returns zero or one outputs of type `T`, and no unprocessed key
    /// events. In order to speed up processing of large sequences of key events (which do
    /// sometimes occur), we allow processing many at a time, returning the full set of outputs.
    /// If a keybinding is waiting on more input, the keys so far will be stored in a local buffer
    /// here until the next call to `get_outputs`.
    ///
    /// The [`switches_provider`] method on [`ModeOutput`] gives a way to stop early, if one of the
    /// outputs in the batch would change the handler for the rest of the input. Switching modes is
    /// not included in this.
    ///
    /// Batches will also stop early if no keybinding is found for a prefix of the provided input,
    /// in order to report the error as part of the output. (Note that the input is still appended
    /// to whatever input may be left in the buffer.
    ///
    /// Because of batching, it is not necessarily the case that returning an output indicates
    /// there are not more keys waiting. This can only be guaranteed if the ending output value
    /// either (a) satisfies [`switches_provider`], or (b) is constructed with
    /// [`ModeOutput::make_failed`] (indicating that there was no applicable keybinding to the
    /// start of the input).
    ///
    /// This function is `async` because evaluating keybindings may involve calling user-defined
    /// named functions, which are `async`.
    ///
    /// [`switches_provider`]: ModeOutput::switches_provider
    pub async fn get_outputs(
        &mut self,
        input: impl IntoIterator<Item = KeyEvent>,
    ) -> (Vec<KeyEvent>, SmallVec<[T; 1]>) {
        // First, pass the input along to the inner mode to be able to handle
        self.current.input.extend(input);

        // A flag to handle when exiting the loop below - if true, we need to return all inputs to
        // the caller.
        let mut clear_buffer = false;

        let mut output = <SmallVec<[T; 1]>>::new();

        loop {
            match self.current.get_output().await {
                MatchResult::Ok(t) => output.push(t),
                MatchResult::Failed(ks) => {
                    output.push(T::make_failed(ks));
                    // The keybinding failed; return the rest of the input to the caller so they
                    // can decide what to do about it
                    clear_buffer = true;
                    break;
                }
                MatchResult::NeedsMore => break,
            }

            // We only get to this point in the loop if we just got a successful match. We now need
            // to check for things about that value.
            let last_output = output.last().unwrap();

            // First up, we check if this requires switching modes. We perform this action, even if
            // the value *also* switches providers.
            //   @req switch-modes-respected v0
            if let Some(kind) = last_output.as_switch_mode() {
                let (name, keys) = self.set[kind].clone();
                let new_mode = Mode::new(name, kind, keys);
                let old = mem::replace(&mut self.current, new_mode);
                self.current.input = old.input;
            }

            // And then, if we need to exit, we do:
            if last_output.switches_provider() {
                clear_buffer = true;
                break;
            }
        }

        let mut returned_keys = Vec::new();
        if clear_buffer {
            returned_keys = mem::replace(&mut self.current.input, Vec::new());
        }

        (returned_keys, output)
    }
}

impl<T: ModeOutput> Mode<T> {
    /// (*Internal*) Constructs a new `Mode`, given the name and keybindings
    fn new(name: impl Into<String>, kind: ModeKind, keys: Arc<KeybindingSet<T>>) -> Self {
        Mode {
            name: name.into(),
            kind,
            input: Vec::new(),
            keys,
        }
    }

    /// (*Internal*) Gets the output from this `Mode`, removing the consumed keys from the internal
    /// buffer if the keybinding is not waiting for more.
    ///
    /// In other words, keys will be consumed if the match succeeds or fails; they will not be
    /// consumed if the `KeybindingSet` is looking for more.
    async fn get_output(&mut self) -> MatchResult<T> {
        use crate::keys::MatchResult::{Matched, NeedsMore, NoMatch};

        match self.keys.matches(&self.input) {
            NeedsMore => MatchResult::NeedsMore,
            Matched { len } => {
                let output = self.keys.output(&self.input[..len]).await;
                self.input.drain(..len);
                MatchResult::Ok(output)
            }
            NoMatch { len } => MatchResult::Failed(self.input.drain(..len).collect()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Some sample output for use in tests
    enum SampleOutput<M, T> {
        NoKeybinding(Vec<KeyEvent>),
        SwitchMode(M),
        SwitchProvider,
        SwitchModeAndProvider(M),
        Success(T),
    }

    impl<T: 'static + Any + Send + Sync> ModeOutput for SampleOutput<ModeKind, T> {
        fn as_switch_mode(&self) -> Option<ModeKind> {
            use SampleOutput::{SwitchMode, SwitchModeAndProvider};

            match self {
                SwitchMode(m) | SwitchModeAndProvider(m) => Some(*m),
                _ => None,
            }
        }

        fn switches_provider(&self) -> bool {
            use SampleOutput::{SwitchModeAndProvider, SwitchProvider};

            matches!(self, SwitchProvider | SwitchModeAndProvider(_))
        }

        fn make_failed(keys: Vec<KeyEvent>) -> Self {
            SampleOutput::NoKeybinding(keys)
        }
    }

    // A simple working demo.
    //
    // This works in a few stages, checking the output and current state of the mode set after
    // each. That way, we can check a range of functionalities within a single test.
    //
    // We're using a very simple set of modes: there's just two: "foo" and "bar", with different
    // keybindings. Both have a way way to generate each one of the four non-failure outputs given
    // above:
    //     SwitchMode, SwitchProvider, SwitchModeAndProvider, and Success
    // The keybindngs are a mix of lengths - some single-letter keybindings and other
    // multi-letters. They're created by mapping the constants for two `KeybindingSet`s to provide
    //
    // TODO-FEATURE: This test is waiting on additional features to be added to `KeybindingSet`s -
    // namely allowing constants.
    #[test]
    fn simple_working_demo() {
        todo!()
    }
}
