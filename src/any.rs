//! Custom support for dynamic typing
//!
//! In short: there are a couple features missing from [`std::any`] that would be useful to have
//! collected into a single space. That place is here.
//!
//! This module doesn't have a whole lot - there are a couple types (e.g. [`Type`], [`BoxedAny`])
//! and a few new traits (e.g. [`DynClone`]), but that's about it. The benefits from this range
//! from better error messages (`Type`), simpler type definitions (`BoxedAny`, mostly), and even
//! some new features (`DynClone`).
//!
//! There isn't a guiding philosophy here; it's mostly just a mixed bag of helpful things. A few
//! relevant things from [`std::any`] are re-exported here.

use std::any::type_name;
use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::hash::{Hash, Hasher};

// Re-export a couple things from the standard library:
pub use std::any::{Any, TypeId};

/// A replacement for [`std::any::TypeId`] with names built-in
///
/// This is essentially just a wrapper around [`TypeId`] so that we can additionally produce the
/// name of the type for error messages.
///
/// A `Type` can only be generated by the [`new`](Self::new) method.
#[derive(Debug, Copy, Clone, Eq)]
pub struct Type {
    id: TypeId,
    name: &'static str,
}

impl PartialEq for Type {
    fn eq(&self, other: &Type) -> bool {
        self.id == other.id
    }
}

impl Hash for Type {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state)
    }
}

impl Type {
    /// Constructs the representation of the concrete type `T`
    pub const fn new<T: Any>() -> Self {
        Type {
            id: TypeId::of::<T>(),
            name: type_name::<T>(),
        }
    }

    /// Returns the [`TypeId`] associated with the type
    ///
    /// This is typically not necessary, unless for debugging, as `Type`s can be compared directly.
    pub fn id(&self) -> TypeId {
        self.id
    }

    /// Returns the name of the type
    ///
    /// This essentially gives the output of [`std::any::type_name`], and - as such - may be
    /// different for equal types. This should only be used to provide diagnostic information.
    pub fn name(&self) -> &'static str {
        self.name
    }
}

/// A wrapper around [`Box<dyn Any + Send + Sync>`](std::any::Any) with the concrete type of the
/// value attached
///
/// The concrete type is exposed through through the [`inner_type`](Self::inner_type) method, and
/// downcasting is provided with [`downcast`](Self::downcast). For a fallible version, there is
/// [`try_downcast`](Self::try_downcast).
///
/// `BoxedAny` is based around the assumption that most of the types used in this program will be
/// required to implement `Send` and `Sync` either way (primarily as due to restrictions from
/// `async` evaluation), and so it's acceptable here as a strict requirement.
pub struct BoxedAny {
    boxed: Box<dyn Any + Send + Sync>,
    inner_ty: Type,
}

impl BoxedAny {
    /// Constructs a new `BoxedAny` with attached type information
    pub fn new<T: Any + Send + Sync>(value: T) -> BoxedAny {
        BoxedAny {
            boxed: Box::new(value),
            inner_ty: Type::new::<T>(),
        }
    }

    /// Consumes the value and downcasts to the correct type
    ///
    /// This method will panic if the type does not match what's expected - it's essentially
    /// equivalent to
    /// ```
    /// self.try_downcast().unwrawp()
    /// ```
    ///
    /// [`BoxedAny::try_downcast`] is the fallible version of this function.
    pub fn downcast<T: Any + Send + Sync>(self) -> T {
        self.try_downcast().unwrap()
    }

    /// Consumes the value and attempts to downcast to the correct type
    ///
    /// If the actual type of the value doesn't match what's expected (i.e. if it isn't `T`), this
    /// method will return the appropriate `TypeError`.
    ///
    /// This method should not be used to test type equivalence; it consumes the inner value. For
    /// that, retrieve the inner type with [`BoxedAny::inner_type`] and compare from there.
    pub fn try_downcast<T: Any + Send + Sync>(self) -> Result<T, TypeError> {
        // We could compare the types beforehand, but it's easier to
        // just attempt to downcast and handle the error.
        match <Box<dyn Any + Send>>::downcast::<T>(self.boxed) {
            Ok(boxed_val) => Ok(*boxed_val),
            Err(_) => Err(TypeError {
                expected: Type::new::<T>(),
                found: self.inner_ty,
            }),
        }
    }

    /// Returns the type of the value contained within this `Box`
    ///
    /// The type here can be used for diagnostics or testing type equivalence, for example:
    /// ```
    /// # use crate::any::{BoxedAny, Type};
    ///
    /// // Check that a value is of type `Vec<&'static str>`:
    ///
    /// let vs = vec!["the", "cake", "is", "a", "lie"];
    /// let boxed = BoxedAny::new(vs);
    ///
    /// assert_eq!(boxed.inner_type(), Type::new::<Vec<&'static str>>());
    /// ```
    pub fn inner_type(&self) -> Type {
        self.inner_ty
    }
}

impl AsRef<dyn Any + Send + Sync> for BoxedAny {
    fn as_ref(&self) -> &(dyn Any + Send + Sync) {
        self.boxed.as_ref()
    }
}

/// An error resulting from calling [`BoxedAny::try_downcast`] with an incorrect value
///
/// The resulting error displayed has the following form:
/// ```text
/// expected `<expected type>`, found `<actual type>`"
/// ```
// @req TypeError-msg v0
/// which - for [`BoxedAny::try_downcast`] gives the type parameter as the expected type and type
/// of the boxed value as the actual type.
#[derive(Debug, Copy, Clone)]
pub struct TypeError {
    expected: Type,
    found: Type,
}

impl Display for TypeError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(
            f,
            // @def TypeError-msg v0
            "expected `{}`, found `{}`",
            self.expected.name(),
            self.found.name()
        )
    }
}

impl Error for TypeError {}
