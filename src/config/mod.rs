//! Handling of configuration for the editor
//!
//! There are broadly two things stored here: The traits for implementing configurable components,
//! alongside the top-level configuration root.
//!
//! The traits are not intended to be manually implemented; the `viri_macros::config!` macro is
//! provided exactly for this purpose (and aliased under [`crate::macros::config`]).

use crate::fs::{self, Path};
use crate::macros::{config, init};
use crate::runtime;
use log::LevelFilter;
use serde::{Deserialize, Serialize};
use std::any::{self, type_name, TypeId};
use std::env;
use std::process::exit;
use std::sync::Arc;

pub mod attr;
pub mod named_fn;

pub use attr::{Attribute, GetAttr, GetAttrAny};
pub use named_fn::NamedFunction;

init! {
    mod named_fn;
    mod attr;
}

// Define the main, crate-level configuation
// @def main-config v0
config! {
    static ROOT_CONFIG;

    /// The main configuration for the application
    ///
    /// Additional modules with configuration should be added here.
    pub struct MainConfig (MainConfigBuilder) {
        #[flatten]
        pub use crate::view::Config as view_config,
        #[flatten]
        pub use crate::container::Config as container_config,

        // NOTE: This really shouldn't be a string but a `fs::Path`, because then the location
        // given here wouldn't change if we changed our current working directory
        #[builder(Option<String>)]
        pub log_file: Option<String>,

        /// The inital log level to use
        ///
        /// Please note that this is not synchronized with calls to [`logger::set_level`], and so
        /// is not guaranteed to be equal at runtime.
        ///
        /// [`logger::set_level`]: crate::logger::set_level
        // @def default-log-level v0
        pub log_level: LevelFilter = LevelFilter::Warn,
    }
}

/// Configurable items that can be accessed at runtime
///
/// While implementing this trait can be done manually, it's typically generated through the
/// `config!` macro, which handles much of the boilerplate here.
pub trait Configurable: Sized {
    /// A type from which the config can be constructed
    ///
    /// This is the type that's actually parsed in order to construct the configuration at runtime.
    type Builder: Builder + Into<Self>;

    /// Returns a reference to the current global configuration
    ///
    /// Within macros, this is generated by the parent configuration, relying on *its*
    /// implementation of `Configurable`.
    fn get_global() -> Arc<Self>;

    /// Converts the configuration into a `Builder` that can be used to exactly re-construct it
    ///
    /// This function is provided as part of the feature set allowing configuration serialization,
    /// hence why `Builder` has the constraint that it must implement `Serialize`.
    fn to_builder(&self) -> Self::Builder;
}

/// A trait for pieces of configuration that are stored as part of another
///
/// The items defined here are really just a subset of what's required for [`Configurable`], so
/// that the [`config`] macro may come and finish the implementation.
pub trait ChildConfig: Sized {
    /// A copy of `Configurable::Builder` for inner configs, so that macros can generate
    /// implemenations of [`Configurable`] given only an impementation of `ChildConfig`.
    ///
    /// For more information, please refer to [`Configurable`]
    type Builder: Builder + Into<Self>;

    /// An copied version of [`Configurable::to_builder`] for the same reason as for `Builder`
    fn to_builder(&self) -> Self::Builder;
}

/// A type that can be deserialized and used to build a [`Configurable`]
///
/// This is really a super-trait for a collection of useful traits for serializing and
/// deserializing. A blanket implementation for all types satisfying the required trait bounds is
/// provided, so a manual implementation of this trait is almost never necessary.
pub trait Builder: Default + Serialize + for<'a> Deserialize<'a> {}

impl<T: Default + Serialize + for<'a> Deserialize<'a>> Builder for T {}

/// Types that may be constructed from a [`Builder`]
///
/// Requirements for this trait to be implemented typically result from the [`config`] macro, where
/// the builders associated with a field (either inferred, or through the `#[builder]` attribute)
/// must implement `FromBuilder`.
///
/// The distinction between the methods on this trait and those provided by [`Configurable`] and
/// [`ChildConfig`] is that these are meant for the individual fields of a config struct, whereas
/// the two above are intended to be used for the full configurations themselves. This distinction
/// is perhaps imperfect, but hopefully should rarely come up.
///
/// To help explain, let's look at a commented example:
/// ```
/// config! {
///     struct Config (ConfigBuilder) {
///         // Without any attribute, the builder type for field is `Option<Option<String>>`, and
///         // so we have the requirement that `Option<String>` implements
///         //    FromBuilder<Option<Option<String>>>
///         default_field: Option<String> = None,
///
///         // When we just specify the builder, the requirement changes to
///         //   Option<String>: FromBuilder<Option<String>>
///         #[builder(Option<String>)]
///         specified_builder: Option<String> = None,
///
///         // And finally, we may also give the conversion functions manually.
///         //
///         // Here, there is no bound involving `FromBuilder`, because we just use these functions
///         // instead. These substitute for `from_builder` and `to_builder`, respectively.
///         #[builder(Option<String> => std::convert::identity, Clone::clone)]
///         specified_all: Option<String> = None,
///     }
/// }
/// ```
///
/// For more information, please refer to the documentation for the [`config`] macro.
#[rustc_on_unimplemented(
    label = "note: if this is from the `config!` macro, functions to convert to/from the builder may be provided manually"
)]
pub trait FromBuilder<B: Builder> {
    /// Constructs the type from a builder
    fn from_builder(builder: B) -> Self;

    /// Produces the builder from a reference to the type
    fn to_builder(&self) -> B;
}

impl<T: Builder + Clone> FromBuilder<T> for T {
    fn from_builder(builder: T) -> T {
        builder
    }

    fn to_builder(&self) -> T {
        T::clone(self)
    }
}

/// The information about a single type
///
/// This is essentially a wrapper around [`TypeId`] so that we can additionally produce the name of
/// the type for error messages.
///
/// A `Type` can only be generated by the [`new`](Self::new) method.
#[derive(Debug, Copy, Clone, Eq)]
pub struct Type {
    id: TypeId,
    name: &'static str,
}

impl PartialEq for Type {
    fn eq(&self, other: &Type) -> bool {
        self.id == other.id
    }
}

impl Type {
    /// Constructs the representation of the concrete type `T`
    pub const fn new<T: any::Any>() -> Self {
        Type {
            id: TypeId::of::<T>(),
            name: type_name::<T>(),
        }
    }

    /// Returns the [`TypeId`] associated with the type
    pub fn id(&self) -> TypeId {
        self.id
    }

    /// Returns the name of the type
    ///
    /// This exactly gives the output of [`std::any::type_name`].
    pub fn name(&self) -> &'static str {
        self.name
    }
}

/// Sets the initial main configuration, parsing from the default file in the configuration
/// directory, if given
///
/// This function can only be run once, at program initialization. As such, it's only called from
/// within `main`.
pub fn set_initial_from_file(cfg_file: Option<&Path>) -> Arc<MainConfig> {
    if ROOT_CONFIG.load().is_some() {
        panic!(
            "cannot set initial configuration, `main_config` module has already been initialized"
        );
    }

    let builder: MainConfigBuilder = runtime::block_on(async {
        #[rustfmt::skip]
        let cfg = (fs::read_to_string(cfg_file.as_ref()?).await)
            .map(|s| serde_yaml::from_str(&s))
            // Unwrap an IO error
            .unwrap_or_else(|e| {
                eprintln!("fatal error: failed to read config file {:?}: {}", cfg_file, e);
                exit(1);
            })
            // Unwrap a serialization error
            .unwrap_or_else(|e| {
                eprintln!("fatal error: failed to parse config file {:?}: {}", cfg_file, e);
                exit(1);
            });

        Some(cfg)
    })
    .unwrap_or_default();

    let arc: Arc<MainConfig> = Arc::new(builder.into());
    ROOT_CONFIG.store(Some(arc.clone()));

    arc
}

/// Attempts to find a directory containing configuration information, checking the standard
/// expected places (at least on Linux)
pub fn find_default_directory_location() -> Option<Path> {
    // For the default config location, we'll look at the following locations in order:
    //   * $XDG_CONFIG_HOME/viri
    //   * $HOME/.config/viri
    //   * $HOME/.viri
    // @def config-file-location v0
    if let Ok(xdg_config_dir) = env::var("XDG_CONFIG_HOME").map(Path::from) {
        // Check $XDG_CONFIG_HOME/viri
        let path = xdg_config_dir.join("viri");
        if path.exists() {
            return Some(path);
        }
    } else if let Ok(home_dir) = env::var("HOME").map(Path::from) {
        // Check $HOME/.config/viri
        let home_config_dir = home_dir.join(".config/viri");
        if home_config_dir.exists() {
            return Some(home_config_dir);
        }

        // Check $HOME/.viri
        let home_dot_viri = home_dir.join(".viri");
        if home_dot_viri.exists() {
            return Some(home_dot_viri);
        }
    }

    None
}
