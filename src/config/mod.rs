//! Handling of configuration for the editor
//!
//! There are broadly two things stored here: The traits for implementing configurable components,
//! alongside the top-level configuration root.
//!
//! The traits are not intended to be manually implemented; the `viri_macros::config!` macro is
//! provided exactly for this purpose (and aliased under [`crate::macros::config`]).

use crate::any::Type;
use crate::fs::{self, Path};
use crate::macros::{config, init};
use crate::runtime;
use log::LevelFilter;
use serde::{Deserialize, Serialize};
use std::env;
use std::sync::Arc;

pub mod attr;
pub mod named_fn;

pub use attr::{Attribute, GetAttr, GetAttrAny};
pub use named_fn::NamedFunction;

init! {
    mod named_fn;
    mod attr;
}

// Define the main, crate-level configuation
// @def main-config v2
config! {
    static ROOT_CONFIG;

    /// The main configuration for the application
    ///
    /// Additional modules with configuration should be added here.
    pub struct MainConfig (MainConfigBuilder) {
        #[flatten]
        pub use crate::container::Config as container_config,

        // NOTE: This really shouldn't be a string but a `fs::Path`, because then the location
        // given here wouldn't change if we changed our current working directory
        #[builder(Option<String>)]
        #[validate_with(|s: &Option<String>| match s.as_ref().map(|s| s.as_str()) {
            Some("") => Err("`log_file` path must be non-empty"),
            _ => Ok(()),
        })]
        pub log_file: Option<String>,

        /// The inital log level to use
        ///
        /// Please note that this is not synchronized with calls to [`logger::set_level`], and so
        /// is not guaranteed to be equal at runtime.
        ///
        /// [`logger::set_level`]: crate::logger::set_level
        // @def default-log-level v0
        pub log_level: LevelFilter = LevelFilter::Warn,
    }
}

/// Configurable items that can be accessed at runtime
///
/// While implementing this trait can be done manually, it's typically generated through the
/// `config!` macro, which handles much of the boilerplate here.
pub trait Configurable: Sized {
    /// A type from which the config can be constructed
    ///
    /// This is the type that's actually parsed in order to construct the configuration at runtime.
    type Builder: Builder + Into<Self>;

    /// Returns a reference to the current global configuration
    ///
    /// Within macros, this is generated by the parent configuration, relying on *its*
    /// implementation of `Configurable`.
    fn get_global() -> Arc<Self>;

    /// Converts the configuration into a `Builder` that can be used to exactly re-construct it
    ///
    /// This function is provided as part of the feature set allowing configuration serialization,
    /// hence why `Builder` has the constraint that it must implement `Serialize`.
    fn to_builder(&self) -> Self::Builder;
}

/// A trait for pieces of configuration that are stored as part of another
///
/// The items defined here are really just a subset of what's required for [`Configurable`], so
/// that the [`config`] macro may come and finish the implementation.
pub trait ChildConfig: Sized {
    /// A copy of `Configurable::Builder` for inner configs, so that macros can generate
    /// implemenations of [`Configurable`] given only an impementation of `ChildConfig`.
    ///
    /// For more information, please refer to [`Configurable`]
    type Builder: Builder + Into<Self>;

    /// An copied version of [`Configurable::to_builder`] for the same reason as for `Builder`
    fn to_builder(&self) -> Self::Builder;
}

/// A type that can be deserialized and used to build a [`Configurable`]
///
/// This is really a super-trait for a collection of useful traits for serializing and
/// deserializing. A blanket implementation for all types satisfying the required trait bounds is
/// provided, so a manual implementation of this trait is almost never necessary.
pub trait Builder: Default + Serialize + for<'a> Deserialize<'a> {}

impl<T: Default + Serialize + for<'a> Deserialize<'a>> Builder for T {}

/// Types that may be constructed from a [`Builder`]
///
/// Requirements for this trait to be implemented typically result from the [`config`] macro, where
/// the builders associated with a field (either inferred, or through the `#[builder]` attribute)
/// must implement `FromBuilder`.
///
/// The distinction between the methods on this trait and those provided by [`Configurable`] and
/// [`ChildConfig`] is that these are meant for the individual fields of a config struct, whereas
/// the two above are intended to be used for the full configurations themselves. This distinction
/// is perhaps imperfect, but hopefully should rarely come up.
///
/// To help explain, let's look at a commented example:
/// ```
/// config! {
///     struct Config (ConfigBuilder) {
///         // Without any attribute, the builder type for field is `Option<Option<String>>`, and
///         // so we have the requirement that `Option<String>` implements
///         //    FromBuilder<Option<Option<String>>>
///         default_field: Option<String> = None,
///
///         // When we just specify the builder, the requirement changes to
///         //   Option<String>: FromBuilder<Option<String>>
///         #[builder(Option<String>)]
///         specified_builder: Option<String> = None,
///
///         // And finally, we may also give the conversion functions manually.
///         //
///         // Here, there is no bound involving `FromBuilder`, because we just use these functions
///         // instead. These substitute for `from_builder` and `to_builder`, respectively.
///         #[builder(Option<String> => std::convert::identity, Clone::clone)]
///         specified_all: Option<String> = None,
///     }
/// }
/// ```
///
/// For more information, please refer to the documentation for the [`config`] macro.
#[rustc_on_unimplemented(
    label = "note: if this is from the `config!` macro, functions to convert to/from the builder may be provided manually"
)]
pub trait FromBuilder<B: Builder> {
    /// Constructs the type from a builder
    fn from_builder(builder: B) -> Self;

    /// Produces the builder from a reference to the type
    fn to_builder(&self) -> B;
}

impl<T: Builder + Clone> FromBuilder<T> for T {
    fn from_builder(builder: T) -> T {
        builder
    }

    fn to_builder(&self) -> T {
        T::clone(self)
    }
}

/// Sets the initial main configuration, parsing from the default file in the configuration
/// directory, if given
///
/// This function can only be run once, at program initialization. As such, it's only called from
/// within `main`.
pub fn set_initial_from_file(cfg_file: Option<&Path>) -> Result<Arc<MainConfig>, String> {
    if ROOT_CONFIG.load().is_some() {
        panic!(
            "cannot set initial configuration, `main_config` module has already been initialized"
        );
    }

    let builder: MainConfigBuilder = match cfg_file.as_ref() {
        None => Default::default(),
        Some(file_path) => {
            #[rustfmt::skip]
            let builder = runtime::block_on(async { fs::read_to_string(file_path).await })
                .map(|s| serde_yaml::from_str(&s))
                // Handle an IO error
                .map_err(|e| {
                    format!("fatal error: failed to read config file {:?}: {}", cfg_file, e)
                })?
                // Handle a serialization error
                .map_err(|e| {
                    format!("fatal error: failed to parse config file {:?}: {}", cfg_file, e)
                })?;

            builder
        }
    };

    let arc: Arc<MainConfig> = Arc::new(builder.into());
    arc.validate()
        .map_err(|e| format!("invalid configuration: {}", e))?;
    ROOT_CONFIG.store(Some(arc.clone()));

    Ok(arc)
}

/// Attempts to find a directory containing configuration information, checking the standard
/// expected places (at least on Linux)
pub fn find_default_directory_location() -> Option<Path> {
    // For the default config location, we'll look at the following locations in order:
    //   * $XDG_CONFIG_HOME/viri
    //   * $HOME/.config/viri
    //   * $HOME/.viri
    // @def config-file-location v0
    if let Ok(xdg_config_dir) = env::var("XDG_CONFIG_HOME").map(Path::from) {
        // Check $XDG_CONFIG_HOME/viri
        let path = xdg_config_dir.join("viri");
        if path.exists() {
            return Some(path);
        }
    } else if let Ok(home_dir) = env::var("HOME").map(Path::from) {
        // Check $HOME/.config/viri
        let home_config_dir = home_dir.join(".config/viri");
        if home_config_dir.exists() {
            return Some(home_config_dir);
        }

        // Check $HOME/.viri
        let home_dot_viri = home_dir.join(".viri");
        if home_dot_viri.exists() {
            return Some(home_dot_viri);
        }
    }

    None
}
