//! Support for (de-)serializable user-defined functions
//
// TODO - this module needs a fair amount of documentation to explain how it works

use super::Type;
use crate::macros::{async_fn, init};
use arc_swap::ArcSwapOption;
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize, Serializer};
use std::any::Any;
use std::collections::HashMap;
use std::convert::TryFrom;
use std::fmt::{self, Debug, Display, Formatter};
use std::sync::Arc;

init! {
    // This isn't really required to be here, but it's nice to have everything in one place.
    inventory::collect!(RegisteredFunction);

    let map = inventory::iter::<RegisteredFunction>()
        .map(|func| (func.name, func))
        .collect();

    REGISTRY.store(Some(Arc::new(map)));
}

lazy_static! {
    /// The internal registry of named functions
    static ref REGISTRY: ArcSwapOption<HashMap<&'static str, &'static RegisteredFunction>>
        = ArcSwapOption::empty();
}

/// (*Internal*) The type of the function pointer generated by the [`named`] attribute macro
///
/// ```
/// // Note: the signature is actually more like this:
/// type FnPtr = async fn(Vec<Box<dyn Any + Send + Sync>>) -> Box<dyn Any + Send + Sync>;
/// ```
///
/// This is primarily for internal use, and exists only as an abbreviation.
///
/// [`named`]: crate::macros::named
pub type FnPtr = async_fn![fn(Vec<Box<dyn Any + Send + Sync>>) -> Box<dyn Any + Send + Sync>];

/// (*Internal*) The inner representation of a named function
///
/// This type is only exposed so that the [`named`] attribute macro can reference it for
/// registering the function under the given name.
///
/// [`named`]: crate::macros::named
#[derive(Clone)]
pub struct RegisteredFunction {
    name: &'static str,
    input: Vec<Type>,
    output: Type,
    fn_ptr: FnPtr,
}

impl RegisteredFunction {
    /// Constructs a new `RegisteredFunction`
    ///
    /// This is only really for internal use by the [`named`] attribue macro.
    ///
    /// [`named`]: crate::macros::named
    pub fn new(name: &'static str, input: Vec<Type>, output: Type, fn_ptr: FnPtr) -> Self {
        RegisteredFunction {
            name,
            input,
            output,
            fn_ptr,
        }
    }
}

/// A user-provided function, accessible by name
///
/// This type is exposed entirely for the purposes of (de-)serializing for configs. Typically, user
/// code will not need to manipulate these directly, but will instead go through configuration
/// files that serialize/deserialize these.
///
/// For creating a custom named function, please refer to the documentation for the [`named`]
/// attribute macro. For a general overview of named functions, see the
/// [module-level documentation](self).
///
/// [`named`]: crate::macros::named
#[derive(Copy, Clone, Debug, Deserialize)]
#[serde(try_from = "&str")]
pub struct NamedFunction(&'static RegisteredFunction);

impl NamedFunction {
    /// Returns an error if the provided input types don't match what's expected by this function
    pub fn correct_input_types<Iter>(&self, input_types: Iter) -> Result<(), BadInput>
    where
        Iter: ExactSizeIterator<Item = Type>,
    {
        if input_types.len() != self.0.input.len() {
            return Err(BadInput::IncorrectNumberOfArgs {
                given: input_types.len(),
                func: self.0,
            });
        }

        for (idx, ty) in input_types.enumerate() {
            if ty != self.0.input[idx] {
                return Err(BadInput::TypeMismatch {
                    idx,
                    given: ty,
                    func: self.0,
                });
            }
        }

        Ok(())
    }

    /// Returns the name given to the function
    pub fn name(&self) -> &'static str {
        self.0.name
    }

    /// Returns the output type of the function
    pub fn output_type(&self) -> Type {
        self.0.output
    }

    /// Evaluates the function with the given inputs
    ///
    /// If the input types do not match what is expected, this function will panic. Input types
    /// should be validated before calling this function with [`correct_input_types`].
    ///
    /// [`correct_input_types`]: Self::correct_input_types
    pub async fn apply(
        &self,
        inputs: Vec<Box<dyn Any + Send + Sync>>,
    ) -> Box<dyn Any + Send + Sync> {
        let output = (self.0.fn_ptr)(inputs).await;
        debug_assert_eq!(output.type_id(), self.0.output.id());

        output
    }
}

/// An unexpected set of inputs to a function
///
/// This is generated by the [`correct_input_types`] method on [`NamedFunction`].
///
/// [`correct_input_types`]: NamedFunction::correct_input_types
#[derive(Copy, Clone, Debug)]
pub enum BadInput {
    IncorrectNumberOfArgs {
        given: usize,
        func: &'static RegisteredFunction,
    },
    TypeMismatch {
        /// The index of the argument that had a mismatched type
        idx: usize,
        given: Type,
        func: &'static RegisteredFunction,
    },
}

///////////////////////////////////
// Debug/Display implementations //
///////////////////////////////////

impl Debug for RegisteredFunction {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        let fn_ptr_addr = self.fn_ptr as *const u8 as usize;

        f.debug_struct("RegisteredFunction")
            .field("name", &self.name)
            .field(
                "input",
                &(self.input).iter().map(Type::name).collect::<Vec<_>>(),
            )
            .field("output", &self.output.name())
            .field("fn_ptr", &format!("<fn pointer: {:#x}>", fn_ptr_addr))
            .finish()
    }
}

impl Display for BadInput {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        use BadInput::{IncorrectNumberOfArgs, TypeMismatch};

        match self {
            IncorrectNumberOfArgs { given, func } => write!(
                f,
                "incorrect number of arguments to function '{}': expected {}, found {}",
                func.name,
                func.input.len(),
                given,
            ),
            TypeMismatch { idx, given, func } => write!(
                f,
                "type mismatch on argument '{}': expected `{}`, found `{}`",
                idx,
                func.input[*idx].name(),
                given.name(),
            ),
        }
    }
}

impl std::error::Error for BadInput {}

////////////////////////////////////////////
// (De-)Serialization for `NamedFunction` //
////////////////////////////////////////////

impl Serialize for NamedFunction {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        serializer.serialize_str(self.0.name)
    }
}

impl TryFrom<&str> for NamedFunction {
    type Error = String;

    fn try_from(name: &str) -> Result<NamedFunction, String> {
        let guard = REGISTRY.load();
        let registry = guard
            .as_ref()
            .expect("cannot deserialize before `config::named_fn` has been initialized");

        match registry.get(name) {
            None => Err(format!("cannot find named function '{}'", name)),
            Some(func) => Ok(NamedFunction(*func)),
        }
    }
}
