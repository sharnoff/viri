//! Everything keybindings - using, loading, etc.
//!
//! The primary export of this module is the [`KeybindingSet`], which encapsulates the majority of
//! the external usage that might be desired here. The module doucmentation here serves primarily
//! to describe the ecosystem as a whole.
//!
//! ## Motivation & Design Criteria
//!
//! The way keybindings are manufactured in the editor is non-trivial. There are a few goals of
//! this system:
//! 1. Keybindings can be built from others - e.g. one way to delete is by the key 'd', followed by
//!    a `Movement`
//! 2. Users can easily define and override keybindings
//! 3. Conflicts between keybindings are disallowed and reported
//!
//! In order to do this, we build keybindings from the bottom up as a **very** limited subset of
//! regular expressions. All keybindings are determined purely from the global configuration file,
//! where they can be constructed in terms of each other. The global keybinding set is given by a
//! union-of-(concatenation-of-(union-of- ... (repetition-of keys) ... )). This allows us to match
//! greedily here, so long as there aren't any keybindings that exist as a prefix of another, e.g.
//! both "d" and "dd". Hence prefix-overlapping (a term I just made up) is not allowed.
//!
//! In addition to the *structure* given here, keybindings are also typed! They start as a simple
//! sequence of atomics (e.g. "[1-9]", "[0-9]*") but can be mapped by [named functions]. Hence a
//! sequence of numbered characters can be transformed to an integer, to later be used in
//! keybindings. Constants are also provided with the [dynamic deserialization] facilities from
//! [`crate::any`]
//!
//! [named functions]: crate::config::NamedFunction
//! [dynamic deserialization]: crate::any::deserialize_dyn_clone
//!
//! ## Internal pipeline
//!
//! The process of constructing a [`KeybindingSet`] is relatively complex. The general pattern we
//! use here is to deserialize into unvalidated structs (e.g. [`UncheckedKeybindingSet`]), and then
//! validate into the desired type with an implementation of [`TryFrom`].
// TODO-DOC
//!
//! [`UncheckedKeybindingSet`]: set::UncheckedKeybindingSet
//!
//! For more information on the internal construction of keybindings, see [`Component`].

mod component;
mod de;
mod set;

use component::{AnnotatedComponent, AnnotatedComponentKind, Info, KeySet};
pub use set::KeybindingSet;

/// The result of attempting to match an input key sequence on a [`KeybindingSet`]
///
/// This type is primarily generated by the [`KeybindingSet::matches`] method, though it is also
/// used internally for similar purposes. Wherever a conclusive result is given, the number of keys
/// that were required to reach that result is given as well. For
/// [`ModeSet`](crate::modes::ModeSet), this exactly indicates the number of keys that will be
/// removed from the internal buffer because of this match.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum MatchResult {
    /// The matching was inconclusive; the keys given so far produced a partial, unterminated match
    NeedsMore,
    /// A successful match was found, with the provided length
    Matched { len: usize },
    /// The values of the input `keys[..=len - 2]` produced a partial match, but `keys[len - 1]`
    /// could not continue any applicable match
    NoMatch { len: usize },
}
