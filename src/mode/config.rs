//! Helper types for separate configuration of `Mode`s
//!
//! This module is distinct from [`crate::config`], but makes heavy use of it. There are two
//! central types defined here: [`BaseConfig`] and [`ExtConfig<T>`]. The first acts as a base
//! configuration that will work for any [`Mode<T>`] (by virtue of producing [`Cmd<!>`]), whereas
//! the second allows unique extensions to that configuration made with specific generic types, and
//! possible changes to those.
//!
//! On top of this, there's also the [`ExtendsCfg`] trait, which allows abstracting over both of
//! these with functions that produce boxed trait objects giving configurations for individual
//! modes.
//!
//! Individual modes *also* define their own versions of both the types and the trait - these are
//! all directly used to *compose* these higher-level values. As an immediate example, the
//! `ExtendsCfg` trait defines a method `insert`, which returns a boxed trait-object of
//! `insert::ExtendsCfg`. For more detail, please refer to the definitions of each of these three.
//!
// TODO: Abstract over these with macros for producing traits
//
// TODO: For an example of usage, see [`views::file`] with its `ExtConfig<views::MetaCmd<FileMeta>>`
//!
//! [`crate::config`]: ../../config/index.html
//! [`Config`]: struct.Config.html
//! [`ExtConfig<T>`]: struct.ExtConfig.html
//! [`Mode<T>`]: ../trait.Mode.html
//! [`Cmd<!>`]: ../enum.Cmd.html
//! [`views::file`]: ../../views/file/index.html
//! [`ExtendsCfg`]: trait.ExtendsCfg.html

use super::{insert, normal};
use std::ops::Deref;

mode_config_types! {
    /// The base configuration for a set of modes
    ///
    /// This is auto-generated by the `mode_config_types` macro (unfortunately no source - see
    /// 'src/mode/macros.rs'), and is composed of the base configurations for each of the
    /// configurable modes here.
    ///
    /// Configurations may be extended with [`ExtConfig`] (not to be confused with [`ExtendsCfg`],
    /// a generic interface for configurations).
    ///
    /// [`ExtConfig`]: struct.ExtConfig.html
    /// [`ExtendsCfg`]: struct.ExtendsCfg.html
    #[derive(Default)]
    pub struct BaseConfig {
        pub insert: Config => ExtConfig<T>, impl ExtendsCfg<T>, <Ifn>,
        pub normal: Config => ExtConfig<T>, impl ExtendsCfg<T>, <NFn>,
    }

    /// A generic configuration that extends `BaseConfig`
    ///
    /// Just how [`BaseConfig`] is entirely composed of the base configuration types for each mode,
    /// this type is composed of the extension structs for each.
    ///
    /// This is auto-generated by the `mode_config_types` macro.
    ///
    /// [`BaseConfig`]: struct.BaseConfig.html
    pub struct ExtConfig<T> = ...;

    /// A trait for configurations, implemented both by [`BaseConfig`] and [`ExtConfig`]
    ///
    /// This is auto-generated by the `mode_config_types` macro. The `parent` method is used for
    /// configuration extensions, as a way to give the configuration being extended. For example,
    /// [`BaseConfig`] returns `None`, whereas [`ExtConfig`] values will always return `Some` -
    /// which may in turn give `Some` for *its* parent. In practice, this only occurs in a few
    /// select places, but is worth accounting for.
    ///
    /// [`BaseConfig`]: struct.BaseConfig.html
    /// [`ExtConfig`]: struct.ExtConfig.html
    pub trait ExtendsCfg<T> {
        fn parent(&self) -> Option<Box<dyn ExtendsCfg<T>>>;
    }

    /// A helper function for manual production of [`ExtendsCfg`] trait objects
    ///
    /// The `aux` field should be a closure that produces some value, used as an input for all
    /// other functions for producing the individual mode configuration trait objects.
    ///
    /// [`ExtendsCfg`]: trait.ExtendsCfg.html
    pub fn dyn_extends_cfg<...>(...) -> Box<dyn ExtendsCfg<T>>;
}

/// Returns the list of this configuration, plus all parent configurations after it
///
/// This is used in cases where parent configurations may themselves have parent configurations to
/// collect everything into a list.
///
/// In practice, this tops out at ~3 total values returned, but the flexibility still allows for
/// an unbounded number of these.
pub fn get_all<'a, T>(ext_cfg: Box<dyn 'a + ExtendsCfg<T>>) -> Vec<Box<dyn 'a + ExtendsCfg<T>>> {
    let mut v = match ext_cfg.parent() {
        Some(p) => get_all(p),
        None => Vec::new(),
    };

    v.insert(0, ext_cfg);
    v
}
