//! Various macros for use across the editor
//!
//! This module works in conjunction with the `viri-macros` crate, which provides some of the
//! backing procedural macros necessary for this to work. Generally, `viri-macros` is treated as
//! the backend workhorse, and this module just gives a nice interface into those macros.
//!
//! Macros defined here should *always* be preferred to those given by `viri-macros`, for the sake
//! of making refactoring easier. The only exception is given for [`viri_macros::config`], which
//! does not function from within a declarative macro.

/// Produces a configuration struct with an associated implementation of [`Configurable`]
///
/// This macro may be invoked in either of two modes: with or without a leading `static <IDENT>`,
/// which indicates whether to treat the configuration struct as a component of another *or* as a
/// top-level coniguration with a related static item to store the value in.
///
/// ## Example
///
/// The typical usage that we might expect can be found in [`crate::config`]:
// @req main-config v0
/// ```
/// config! {
///     // Define the name of the static item storing the configuration
///     // This piece is optional; omitting it allows the config to be used as *part* of another,
///     // via the `use` statements below:
///     static ROOT_CONFIG;
///
///     // The main configuration name, paired with the name of the builder used to construct it
///     pub struct MainConfig (MainConfigBuilder) {
///         // Sub-configurations can be included with a `use` declaration:
///         #[flatten]
///         // the #[flatten] attribute allows us to specify that the fields of this configuration
///         // should be merged for deserialization into the builder
///         pub use crate::view::Config as view_config,
///
///         // Each field is given a value to indicate what it defaults to if not provided
///         #[builder(Option<String> => std::convert::identity, Clone::clone)]
///         // Because the default field type used for the builder is `Option<T>`, the `#[builder]`
///         // attribute allows us to specify the type of the builder's field. The two remaining
///         // arguments give, in order (for config type C and builder type B):
///         //  1. a function of B -> C, and
///         //  2. a function of &C -> B
///         pub log_file: Option<String> = None,
///         pub log_level: LevelFilter = LevelFilter::Warn,
///     }
/// }
/// ```
///
/// [`Configurable`]: crate::config::Configurable
pub use viri_macros::config;

/// A marker trait for modules that are initialized at some point
///
/// With each `init!` macro expansion, we insert a dummy type that's expected to have `Initialized`
/// implemented on it. If not, that causes a nice compiler error, using
/// `#[rustc_on_unimplemented]`.
#[rustc_on_unimplemented(
    message = "Initializer is never called",
    label = "generated by this macro"
)]
pub trait Initialized {
    type This;
}

/// Produces an intializer function for the current module
///
/// This macro just takes a block expression as input, with a small modification added to it: Each
/// statement on the *top level* that's of the form `mod <name>` will intead be transformed to run
/// the initializer for that module.
///
/// For a similar macro that does *not* wrap this in a function, see [`initialize`].
///
/// The [`require_initialized`] macro is also available for asserting that a module has been
/// initialized.
///
/// ## Example
///
/// To use an existing piece of code as an example, the [`runtime`](crate::runtime) module contains
/// the following snippet:
/// ```no_run
// @req runtime::init v0
/// init! {
///    lazy_static::initialize(&EXECUTOR);
///
///    mod panic; // equivalent to `initialize! { mod panic; }`
/// }
/// ```
/// So for the runtime, the `init` macro is used to ensure that the values
pub use viri_macros::init;

/// A version of the [`init`] macro that instead produces an expression
///
/// This is really only intended to be used as the entrypoint for initialization, in `main`. It's
/// *probably* not what you're looking for, but it's here nonetheless.
pub use viri_macros::initialize;

/// An assertion that a certain module has been initialized
///
/// This is mostly used in runtime-related functions (e.g. inside logger utilities) to ensure that
/// they aren't being called before they should be.
///
/// Typical usage might look like:
/// ```no_run
/// require_initialized!(crate::runtime);
/// ```
pub use viri_macros::require_initialized;
